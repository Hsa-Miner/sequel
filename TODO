# block form of Model.new:

  MyModel.new do |model
    model.field = value
    model.save
  end

# Save only changed fields for model.

# Smarter one_to_one: stuff like:

  # assuming the Author's primary key is :name
  post = Post.create(:name => 'The Lover', :author => Author['A.B. Yehoshua'])
  post.set(:author => Author['A.B. Yehoshua'])
  
  Book.filter_by_author(Author[:name => 'Kurt Vonnegut']).print

  #and also
  post = Post.create(:name => 'The Lover', :author => 'A.B. Yehoshua') #=> fetches the author record
  post.set(:author => 'A.B. Yehoshua')

* adapter specs for Model

* Add Dataset#update_or_create:

  DB[:items].filter(:name => 'abc').update_or_create(:price => 100)
  
  # equivalent to:
  
  if (DB[:items].filter(:name => 'abc').update(:price => 100) < 1)
    DB[:items] << {:name => 'abc', :price => 100}

  MySQL also supports a REPLACE INTO syntax which does the same:

    REPLACE INTO items SET price = 100 WHERE name = 'abc'

* many_to_many smart relationships.

* schema extraction and database dumping and copying.

* Adapters: 

  frontbase, interbase (http://ruby-dbi.rubyforge.org/)
  openbase (http://ruby-openbase.rubyforge.org)
